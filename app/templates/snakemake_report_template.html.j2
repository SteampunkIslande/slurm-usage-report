<!doctype html>
<html lang="fr">

<head>
  <meta charset="utf-8">
  <title>Rapport d'efficacité snakemake</title>
  <style>
    /* Reset and base */
    :root {
      --bg: #f8fafc;
      --card: #ffffff;
      --muted: #6b7280;
      --accent: #0f4c81;
      --border: #e6edf3;
      --stripe: #f3f6f9;
    }

    html,
    body {
      height: 100%;
    }

    body {
      font-family: Inter, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
      background: var(--bg);
      color: #0b1724;
      margin: 24px;
      line-height: 1.5;
    }

    h1 {
      color: var(--accent);
      margin-bottom: 8px;
      font-weight: 600;
    }

    h2 {
      color: #0b2638;
      margin-top: 20px;
      font-size: 1.1rem;
      font-weight: 600;
    }

    p {
      color: var(--muted);
      max-width: 75ch;
    }

    /* Table styling: make pandas .dataframe scrollable and elegant */
    .dataframe {
      display: block;
      width: 100%;
      overflow: auto;
      background: var(--card);
      border: 1px solid var(--border);
      border-radius: 8px;
      box-shadow: 0 1px 2px rgba(11, 24, 36, 0.04);
      margin-top: 12px;
    }

    .dataframe table {
      width: 100%;
      border-collapse: collapse;
      min-width: 600px;
    }

    .dataframe thead th {
      position: sticky;
      top: 0;
      background: linear-gradient(180deg, #ffffff, #f7fbff);
      border-bottom: 1px solid var(--border);
      padding: 10px 12px;
      text-align: left;
      font-weight: 600;
      color: #0b2638;
      font-size: 0.95rem;
    }

    .dataframe tbody td {
      padding: 10px 12px;
      border-bottom: 1px dashed var(--border);
      color: #102028;
      font-size: 0.95rem;
    }

    .dataframe tbody tr:nth-child(even) td {
      background: var(--stripe);
    }

    .dataframe tfoot td {
      padding: 8px 12px;
      font-weight: 600;
    }

    /* Small screens */
    @media (max-width:640px) {
      body {
        margin: 12px;
      }

      .dataframe table {
        min-width: 480px;
      }

      .plot {
        overflow: auto;
      }
    }

    /* Plot container spacing */
    .plot {
      margin: 8px 0 24px;
    }

    /* Badge styling for threshold colors */
    .badge {
      display: inline-block;
      padding: 3px 6px;
      border-radius: 4px;
      font-size: 0.8rem;
      font-weight: 500;
      color: white;
      text-align: center;
      min-width: 20px;
    }
  </style>
</head>

<body>

  {# Macro pour générer un tableau #}
  {% macro render_table(table_data, color_map_name="default", table_class="dataframe") %}
  <div class="{{ table_class }}">
    <table>
      <thead>
        <tr>
          {% for col in table_data.keys() %}
          <th>{{ col | format_header | safe }}</th>
          {% endfor %}
        </tr>
      </thead>
      <tbody>
        {# Déterminer le nombre de lignes #}
        {% set first_col = table_data.keys() | first %}
        {% set num_rows = table_data[first_col] | length %}

        {% for row_idx in range(num_rows) %}
        <tr>
          {% for col in table_data.keys() %}
          <td>
            {% set cell_value = table_data[col][row_idx] %}
            {% set badge_color = cell_value | get_color(col) %}

            {% if badge_color %}
            <span class="badge" style="background-color: {{ badge_color }};">
              {% if cell_value is number %}{{ cell_value | round(3) }}{% else %}{{ cell_value }}{% endif %}
            </span>
            {% else %}
            {% if cell_value is number %}
            {{ cell_value | round(3) }}
            {% else %}
            {{ cell_value }}
            {% endif %}
            {% endif %}
          </td>
          {% endfor %}
        </tr>
        {% endfor %}
      </tbody>
    </table>
  </div>
  {% endmacro %}

  <h1>Rapport d'efficacité snakemake</h1>

  <h2>Comment utiliser ce rapport pour optimiser vos pipelines</h2>
  <p>
    Ce rapport analyse trois métriques clés de vos jobs Snakemake : l'efficacité mémoire, l'efficacité CPU et la durée
    d'exécution.
    Utilisez les recommandations ci-dessous pour améliorer les performances de vos pipelines et réduire le temps
    d'exécution.
  </p>

  <h2>Efficacité mémoire (%)</h2>
  <p>
    Cette métrique correspond au rapport entre la mémoire réellement utilisée et la mémoire demandée.
    <br>
    Elle mesure, pour chaque règle Snakemake, à quel point la mémoire allouée a été utilisée.
    <br>
    <strong>Attention :</strong> pour les jobs de moins de 30 secondes, la consommation affichée peut ne pas être
    représentative de ce que le job a réellement consommé, en raison de la fréquence d'échantillonnage de SLURM.
  </p>


  <p>
    <strong>Interprétation des valeurs :</strong>
  </p>
  <ul>
    <li>
      <strong>≈ 100&nbsp;%</strong> : allocation mémoire bien ajustée. C'est l'objectif à atteindre.
    </li>
    <li>
      <strong>> 100&nbsp;%</strong> : risque de dépassement mémoire. Le job a utilisé plus de mémoire que demandé.
    </li>
    <li>
      <strong>
        < 50&nbsp;%</strong> : mémoire sur-allouée. Les ressources réservées sont largement supérieures aux
          besoins réels.
    </li>
  </ul>

  <p>
    <strong>Conseils d'optimisation :</strong>
  </p>
  <ul>
    <li>
      <strong>Si l'efficacité est proche de 100&nbsp;%</strong> : votre allocation est optimale, aucune modification
      nécessaire.
    </li>
    <li>
      <strong>Si l'efficacité dépasse 100&nbsp;%</strong> : augmentez la valeur <code>mem_mb</code> dans les ressources
      de votre pipeline pour éviter que le job ne soit tué par manque de mémoire. Essayez également de voir si la tâche
      que vous lancez pourrait consommer moins de mémoire, en modifiant par exemple les options d'exécution.
    </li>
    <li>
      <strong>Si l'efficacité est inférieure à 50&nbsp;%</strong> : réduisez la valeur <code>mem_mb</code> dans les
      ressources de votre pipeline pour libérer des ressources et permettre ainsi à plus de jobs de s'exécuter
      simultanément sur le cluster.
    </li>
  </ul>

  <p>
    Objectif recommandé : viser une efficacité mémoire comprise entre <strong>80&nbsp;% et 100&nbsp;%</strong>.
  </p>

  {{ render_table(efficiency_table_mem) }}

  <h2>Efficacité mémoire (représentation graphique)</h2>
  <p class="plot">
    {{ mem_box_plot | safe }}
  </p>

  {% if efficiency_table_relative_runtime %}
  <h2>RAM utilisée par Mo d'entrée (table)</h2>
  <p>
    Ces statistiques rapportent la RAM utilisée au volume d'entrée (Mo). Elles permettent d'estimer la consommation
    mémoire en fonction de la taille des données d'entrée pour chaque job.
    A partir du maximum de cette valeur, qui est en Mo par Mo, vous pouvez directement calculer la ressource mem_mb pour
    la règle considérée (dans la directive resources: mem_mb=lambda input: input.size_mb * coeff).
    Le boxplot correspondant permet de voir si cette relation est proportionnelle: plus l'écart-type sera faible et les
    valeurs min et max rapprochées, plus cette relation est linéaire et corrélée (en première approximation).
  </p>
  {{ render_table(efficiency_table_relative_mem) }}

  <h2>RAM utilisée par Mo d'entrée (boxplot)</h2>
  <p class="plot">
    {{ relative_mem_box_plot | safe }}
  </p>
  {% else %}
  <p style="font-weight: bold;">Les tailles des fichiers d'entrée n'ont malheureusement pas pu être récupérées pour ce
    run.</p>
  {% endif %}

  <h2>Efficacité CPU (%)</h2>
  <p>
    Cette métrique correspond à :
    <br>
    <strong>(Temps CPU total en secondes) / (Temps wall clock en secondes × Nombre de CPUs alloués) × 100</strong>
    <br>
    Elle mesure, pour chaque règle Snakemake, à quel point les CPUs demandés ont réellement été utilisés.
  </p>

  <p>
    <strong>Interprétation des valeurs :</strong>
  </p>
  <ul>
    <li>
      <strong>≈ 100&nbsp;%</strong> : utilisation optimale. Tous les CPUs alloués ont été utilisés en continu pendant
      toute la durée du job.
    </li>
    <li>
      <strong>
        < 90&nbsp;%</strong> : sous-utilisation. La règle demande probablement trop de CPUs par rapport à ce
          qu'elle utilise réellement. En effet, passé un certain seuil, augmenter le nombre de threads n'a aucun effet
          sur le temps d'exécution. Votre job est alors probablement limité par l'I/O.
    </li>
    <li>
      <strong>> 100&nbsp;%</strong> : sur-utilisation (threads non déclarés). Le programme lance plus de threads que
      le nombre de CPUs demandé à SLURM. Ceci peut représenter un grand danger pour le cluster, SLURM risquant d'allouer
      plus de jobs que la capacité réelle.
    </li>
  </ul>

  <p>
    <strong>Conseils d'optimisation :</strong>
  </p>
  <ul>
    <li>
      <strong>Si l'efficacité est proche de 100&nbsp;%</strong> : votre allocation CPU est optimale, aucune modification
      nécessaire.
    </li>
    <li>
      <strong>Si l'efficacité est inférieure à 70-80&nbsp;%</strong> : réduisez le nombre de <code>threads</code> dans
      la règle Snakemake pour éviter de réserver inutilement des ressources.
    </li>
    <li>
      <strong>Si l'efficacité dépasse 100&nbsp;%</strong> : assurez-vous que le nombre de threads utilisés par le
      logiciel correspond bien à <code>threads:</code> dans Snakemake. Vérifiez les variables d'environnement
      <code>OMP_NUM_THREADS</code>, <code>MKL_NUM_THREADS</code>, etc. Sinon, vous risquez de surcharger les nœuds du
      cluster.
    </li>
    <li>
      <strong>Si l'efficacité est correcte mais que le job reste lent</strong> : le goulot d'étranglement est
      probablement l'I/O ou la mémoire, pas le CPU.
    </li>
  </ul>

  <p>
    Objectif recommandé : viser une efficacité CPU comprise entre <strong>85&nbsp;% et 100&nbsp;%</strong>.
  </p>

  {{ render_table(efficiency_table_cpu) }}

  <h2>Efficacité CPU (représentation graphique)</h2>
  <p class="plot">
    {{ cpu_box_plot | safe }}
  </p>

  <h2>Durée d'exécution (en secondes)</h2>
  <p>
    La table ci-dessous mesure, pour chaque règle Snakemake, la durée d'exécution totale en secondes.
    <br>
    Cette information est essentielle pour optimiser l'ordonnancement des jobs sur le cluster.
  </p>

  <p>
    <strong>Interprétation des valeurs :</strong>
  </p>
  <ul>
    <li>
      <strong>Jobs courts (< 30 secondes)</strong> : durée très courte, l'overhead du scheduling SLURM peut représenter
          une part importante du temps total.
    </li>
    <li>
      <strong>Jobs moyens (30 secondes - 1 h)</strong> : durée standard, bon compromis entre overhead et utilisation des
      ressources.
    </li>
    <li>
      <strong>Jobs longs (> 1 h)</strong> : durée importante, vérifiez si le pipeline peut être parallélisé
      davantage.
    </li>
  </ul>

  <p>
    <strong>Conseils d'optimisation :</strong>
  </p>
  <ul>
    <li>
      <strong>Si le job est très court (< 5 min)</strong> : privilégiez des jobs plus longs en regroupant plusieurs
          tâches ou en augmentant la granularité des règles pour réduire l'overhead du scheduling SLURM.
    </li>
    <li>
      <strong>Si le job est long (> 1 h)</strong> : vérifiez si le pipeline peut être parallélisé davantage avec
      les directives <code>group</code> ou <code>wildcards</code> pour exécuter des tâches indépendantes en parallèle.
    </li>
    <li>
      <strong>Exploitez le backfill SLURM</strong> : en connaissant la durée de vos jobs, vous pouvez bénéficier du
      mécanisme de backfill de SLURM. Les petits jobs peuvent s'insérer dans les espaces libres entre les gros jobs,
      comme le montre le schéma ci-dessous, optimisant ainsi l'utilisation des ressources du cluster.
    </li>
  </ul>
  <p>
    <img src="https://hpc-wiki.info/mediawiki/hpc_images/c/c8/Scheduler-Tetris.png" style="width: 500px;" />
  </p>

  <p>
    <strong>Conseils généraux pour l'optimisation des pipelines Snakemake :</strong>
  </p>
  <ul>
    <li>
      Utilisez <code>--profile</code> pour configurer les ressources par défaut et éviter de monopoliser le cluster.
    </li>
    <li>
      Exploitez les <code>resources</code> dans vos règles pour déclarer les besoins spécifiques (mémoire, GPU, etc.).
    </li>
    <li>
      Utilisez les règles <code>checkpoint</code> pour adapter le pipeline aux résultats intermédiaires.
    </li>
    <li>
      Utilisez <code>--keep-going</code> pour continuer en cas d'échec d'une règle et identifier rapidement les
      problèmes.
    </li>
  </ul>

  {{ render_table(efficiency_table_runtime) }}

  <h2>Durée d'exécution (représentation graphique)</h2>
  <p class="plot">
    {{ runtime_box_plot | safe }}
  </p>

  {% if efficiency_table_relative_runtime %}
  <h2>Durée d'exécution par Mo d'entrée</h2>
  <p>
    Temps d'exécution rapporté à la taille d'entrée (minutes/Mo). Permet de projeter la durée des jobs en fonction du
    volume des données initiales.
  </p>
  {{ render_table(efficiency_table_relative_runtime) }}

  <h2>Durée d'exécution par Mo d'entrée (boxplot)</h2>
  <p>
    Plus ces valeurs sont rapprochées, plus la durée d'exécution est corrélée avec la taille des fichiers d'entrée,
    et de de façon linéaire (en première approximation).
  </p>
  <p class="plot">
    {{ relative_runtime_box_plot | safe }}
  </p>
  {% else %}
  <p style="font-weight: bold;">Les tailles des fichiers d'entrée n'ont malheureusement pas pu être récupérées pour ce
    run.</p>
  {% endif %}

</body>

</html>